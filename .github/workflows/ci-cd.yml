name: CI/CD - Build & Deploy (EC2 Self-Hosted)

on:
  push:
    branches: [ "dev", "main" ]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: self-hosted

    env:
      # Pin the Compose project name so labels/imagery are predictable and scoping is safe
      COMPOSE_PROJECT_NAME: buzzly
      DOCKER_BUILDKIT: 1

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create backend/.env from repo secrets
        run: |
          set -euo pipefail
          mkdir -p backend
          printf "%s" "${{ secrets.BACKEND_ENV_DEV }}" > backend/.env
          chmod 600 backend/.env

      - name: Verify Docker & Compose
        run: |
          docker version
          docker compose version

      - name: Disk & Docker usage (before)
        run: |
          df -h
          docker system df || true

      # ---------- Build ----------
      - name: Build services (uses env file)
        run: |
          set -euo pipefail
          COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} \
          docker compose --env-file backend/.env build --pull

      # ---------- Ensure DB ----------
      - name: Ensure Postgres exists and is healthy (only create if missing/unhealthy)
        run: |
          set -euo pipefail
          # Look for our project's Postgres container
          DB_ID=$(docker ps -a -q --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" --filter "name=postgres")
          if [ -z "$DB_ID" ]; then
            echo "Postgres container not found for project ${COMPOSE_PROJECT_NAME}, creating..."
            COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} \
            docker compose --env-file backend/.env up -d postgres
          else
            echo "Found Postgres container: $DB_ID"
          fi

          # Wait for health=healthy (up to ~90s)
          for i in {1..30}; do
            STATUS=$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}unknown{{end}}' \
              $(docker ps -q --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" --filter "name=postgres") 2>/dev/null || echo "unknown")
            echo "Postgres health: $STATUS"
            if [ "$STATUS" = "healthy" ]; then
              echo "Postgres is healthy."
              break
            fi
            if [ "$STATUS" = "unhealthy" ] || [ "$STATUS" = "unknown" ]; then
              # If it's there but not healthy, ensure it's started
              COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} \
              docker compose --env-file backend/.env up -d postgres
            fi
            sleep 3
          done

      # ---------- Start app services ----------
      - name: Start/Update backend and frontend (keep DB up)
        run: |
          set -euo pipefail
          COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} \
          docker compose --env-file backend/.env up -d --force-recreate --no-deps backend frontend

      # ---------- Smoke checks ----------
      - name: Smoke check - backend on :5000 (IPv4)
        run: |
          set -e
          for i in {1..120}; do
            code=$(curl -4 -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5000/api/health || true)
            if [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then
              echo "Backend OK at /api/health ($code)"; exit 0
            fi
            code2=$(curl -4 -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5000/ || true)
            if [ "$code2" -ge 200 ] && [ "$code2" -lt 400 ]; then
              echo "Backend OK at / ($code2)"; exit 0
            fi
            sleep 2
          done
          echo "Backend did not become healthy in time."
          echo "---- Backend logs (tail) ----"
          COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} \
          docker compose --env-file backend/.env logs --no-color --tail=200 backend || true
          exit 1

      - name: Smoke check - frontend on :80 (IPv4)
        run: |
          curl -4 -sS -I http://localhost/ | head -n 1

      - name: Show status & recent logs (non-fatal)
        if: always()
        run: |
          COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} docker compose --env-file backend/.env ps || true
          echo "---- Backend logs (tail) ----"
          COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} docker compose --env-file backend/.env logs --no-color --tail=200 backend || true
          echo "---- Frontend logs (tail) ----"
          COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} docker compose --env-file backend/.env logs --no-color --tail=200 frontend || true
          echo "---- Postgres logs (tail) ----"
          COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} docker compose --env-file backend/.env logs --no-color --tail=80 postgres || true

      # ---------- Scoped cleanup (project-only) ----------
      - name: Cleanup (project-only; won't touch others)
        if: always()
        run: |
          set -euo pipefail
          # Remove exited containers from THIS project only
          docker ps -a \
            --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" \
            --filter "status=exited" -q | xargs -r docker rm -v

          # Remove dangling images built for THIS project only (buzzly-backend/frontend that are dangling)
          docker images --format '{{.Repository}} {{.ID}} {{.Dangling}}' | \
            awk '$1 ~ /^'${COMPOSE_PROJECT_NAME}'-(backend|frontend)$/ && $3 == "true" {print $2}' | \
            xargs -r docker rmi

          # Remove dangling volumes for THIS project only (will never remove an in-use volume)
          docker volume ls -qf dangling=true -f "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" | \
            xargs -r docker volume rm

      - name: Disk & Docker usage (after)
        if: always()
        run: |
          df -h
          docker system df || true
