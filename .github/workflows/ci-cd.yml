name: CI/CD - Build & Deploy (EC2 Self-Hosted)

on:
  push:
    branches: [ "dev", "main" ]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create backend/.env
        run: |
          set -euo pipefail
          mkdir -p backend
          printf "%s" "${{ secrets.BACKEND_ENV_DEV }}" > backend/.env
          chmod 600 backend/.env

      - name: Verify Docker & Compose
        run: |
          docker version
          docker compose version

      - name: Disk & Docker usage (before)
        run: |
          df -h
          docker system df || true

      # ⚠️ Removed global prunes so we don't touch other teams' containers/images

      - name: Build containers (with env)
        run: |
          set -euo pipefail
          docker compose --env-file backend/.env build --pull

      # ✅ Ensure DB is up; if already running, do nothing. If missing/stopped, start it.
      - name: Ensure Postgres is running (don’t bounce)
        run: |
          set -euo pipefail
          DB_CONTAINER=buzzly-postgres

          if docker ps --format '{{.Names}}' | grep -qx "$DB_CONTAINER"; then
            echo "Postgres is already running."
          else
            if docker ps -a --format '{{.Names}}' | grep -qx "$DB_CONTAINER"; then
              echo "Starting existing Postgres container..."
              docker start "$DB_CONTAINER"
            else
              echo "Creating Postgres via compose..."
              docker compose --env-file backend/.env up -d postgres
            fi
          fi

          echo "Waiting for Postgres to be healthy..."
          for i in {1..60}; do
            status=$(docker inspect -f '{{.State.Health.Status}}' "$DB_CONTAINER" 2>/dev/null || echo "none")
            if [ "$status" = "healthy" ]; then
              echo "Postgres is healthy."; exit 0
            fi
            # Fallback if healthcheck is missing
            if docker exec "$DB_CONTAINER" pg_isready >/dev/null 2>&1; then
              echo "Postgres reports ready."; exit 0
            fi
            sleep 2
          done
          echo "Postgres did not become healthy in time."; exit 1

      - name: Start/Update stack (apps only; keep DB up)
        run: |
          set -euo pipefail
          docker compose --env-file backend/.env up -d --force-recreate --no-deps backend frontend

      # --- smoke checks ---
      - name: Smoke check - backend on :5000 (IPv4)
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -4 -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5000/api/health || true)
            if [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then
              echo "Backend OK at /api/health ($code)"; exit 0
            fi
            code2=$(curl -4 -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5000/ || true)
            if [ "$code2" -ge 200 ] && [ "$code2" -lt 400 ]; then
              echo "Backend OK at / ($code2)"; exit 0
            fi
            sleep 2
          done
          echo "Backend did not become healthy in time."
          echo "---- Backend logs (tail) ----"
          docker compose --env-file backend/.env logs --no-color --tail=200 backend || true
          exit 1

      - name: Smoke check - frontend on :80 (IPv4)
        run: |
          curl -4 -sS -I http://localhost/ | head -n 1

      - name: Show status & recent logs (non-fatal)
        if: always()
        run: |
          docker compose --env-file backend/.env ps || true
          echo "---- Backend logs (tail) ----"
          docker compose --env-file backend/.env logs --no-color --tail=200 backend || true
          echo "---- Frontend logs (tail) ----"
          docker compose --env-file backend/.env logs --no-color --tail=200 frontend || true
          echo "---- Postgres logs (tail) ----"
          docker compose --env-file backend/.env logs --no-color --tail=80 postgres || true

      # ✅ Safe, project-scoped cleanup (won't touch other teams' stuff)
      - name: Project-scoped cleanup (safe)
        if: always()
        run: |
          set -euo pipefail
          # Remove only our stopped containers (names start with buzzly-)
          docker ps -aq -f "name=^buzzly-" -f "status=exited" | xargs -r docker rm -f

          # Remove truly dangling images (global-safe: untagged layers not used by any container)
          docker images -f "dangling=true" -q | xargs -r docker rmi -f

          # Remove dangling volumes that belong to this compose project (safe: none if in use)
          PROJ=$(basename "$GITHUB_WORKSPACE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_.-]/-/g')
          docker volume ls -q --filter "label=com.docker.compose.project=$PROJ" --filter "dangling=true" | xargs -r docker volume rm

      - name: Cleanup old runner workdirs (safe)
        if: always()
        env:
          ROOT: ${{ env.RUNNER_WORKSPACE }}
        run: |
          echo "Runner workspace: ${ROOT:-$RUNNER_WORKSPACE}"
          find "${ROOT:-$RUNNER_WORKSPACE}" -mindepth 1 -maxdepth 1 -type d -mtime +2 \
            ! -path "${GITHUB_WORKSPACE}" -exec rm -rf {} + || true

      - name: Disk & Docker usage (after)
        if: always()
        run: |
          df -h
          docker system df || true
